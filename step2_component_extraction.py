"""
Step 2: 구성 요소 추출
결정된 Lean4 타입에 따라 필요한 구성 요소들을 추출
"""

import json
import re
from typing import List
from huggingface_hub import InferenceClient
from common import Lean4Type, ComponentInfo

class ComponentExtractor:
    """구성 요소 추출기"""
    
    def __init__(self, client: InferenceClient):
        """
        초기화
        
        Args:
            client: Hugging Face InferenceClient 인스턴스
        """
        self.client = client
    
    def extract_components(self, description: str, lean4_type: Lean4Type) -> List[ComponentInfo]:
        """
        구성 요소 추출
        
        Args:
            description: 수학적 객체의 자연어 설명 (LaTeX 포함 가능)
            lean4_type: 1단계에서 결정된 Lean4 타입
            
        Returns:
            List[ComponentInfo]: 구성 요소들
        """
        type_guidance = {
            "inductive": "List all constructors and their full Lean 4 signatures.",
            "structure": "List all fields and their Lean 4 signatures.",
            "class": "List all fields (operations (data), constants, or laws (propositions)) and their Lean 4 signatures."
        }

        prompt = f"""
Extract all components required to define the following mathematical object as a Lean 4 **{lean4_type.value}**.

Description:
{description}

Instructions:
- For **inductive**: {type_guidance['inductive']}
- For **structure**: {type_guidance['structure']}
- For **class**: {type_guidance['class']}

Output format (JSON array):
[
    {{{{
        "name": "component_name (lower_snake_case)",
        "type": "complete Lean 4 type expression",
        "description": "brief explanation (≤ 80 characters)"
    }}}}
]

--- 

### Examples

**Example 1**
lean4_type: inductive
description: "The natural numbers are generated by a base element 0 and the successor operation."
Output:
[
  {{
    "name": "zero",
    "type": "Nat",
    "description": "base constructor representing zero"
  }},
  {{
    "name": "succ",
    "type": "Nat → Nat",
    "description": "successor constructor"
  }}
]

**Example 2**
lean4_type: structure
description: "R^2 is the Cartesian plane consisting of ordered pairs of real numbers."
Output:
[
  {{
    "name": "x",
    "type": "ℝ",
    "description": "x coordinate"
  }},
  {{
    "name": "y",
    "type": "ℝ",
    "description": "y coordinate"
  }}
]

**Example 3**
lean4_type: class
description: "A monoid is a type G equipped with a binary operation and an identity element satisfying associativity and identity laws."
Output:
[
  {{
    "name": "mul",
    "type": "G → G → G",
    "description": "binary operation on G"
  }},
  {{
    "name": "one",
    "type": "G",
    "description": "identity element"
  }},
  {{
    "name": "mul_assoc",
    "type": "∀ a b c : G, mul (mul a b) c = mul a (mul b c)",
    "description": "associativity laws"
  }},
  {{
    "name": "one_mul",
    "type": "∀ a : G, mul one a = a",
    "description": "left identity laws"
  }},
  {{
    "name": "mul_one",
    "type": "∀ a : G, mul a one = a",
    "description": "right identity laws"
  }}
]

**Example 4**
lean4_type: structure  
description: "A monoid homomorphism between monoids M and N is a function preserving identity and multiplication."
Output:
[
  {{
    "name": "to_fun",
    "type": "M → N",
    "description": "underlying function between monoids"
  }},
  {{
    "name": "map_one",
    "type": "to_fun 1 = 1",
    "description": "preserves identity element"
  }},
  {{
    "name": "map_mul",
    "type": "∀ a b, to_fun (a * b) = to_fun a * to_fun b",
    "description": "preserves multiplication"
  }}
]

**Example 5**
lean4_type: inductive
description: "Binary trees with values of type α at internal nodes."
Output:
[
  {{
    "name": "leaf",
    "type": "BinaryTree α",
    "description": "empty tree constructor"
  }},
  {{
    "name": "node",
    "type": "α → BinaryTree α → BinaryTree α → BinaryTree α",
    "description": "internal node with value and two subtrees"
  }}
]

---
"""
        
        try:
            messages = [{"role": "user", "content": prompt}]
            response = self.client.chat_completion(messages, max_tokens=800)
            result_text = response.choices[0].message.content.strip()
            
            # JSON 배열 추출
            json_match = re.search(r'\\[.*\\]', result_text, re.DOTALL)
            if json_match:
                components_data = json.loads(json_match.group())
                
                components = []
                for comp_data in components_data:
                    components.append(ComponentInfo(
                        name=comp_data.get("name", ""),
                        type_annotation=comp_data.get("type", ""), 
                        description=comp_data.get("description", ""),
                    ))
                
                return components
            else:
                return []
                
        except Exception as e:
            print(f"구성 요소 추출 오류: {str(e)}")
            return []